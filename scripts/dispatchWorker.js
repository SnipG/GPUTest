"use strict";self.inputPort=null,self.jobQueue=[],self.jobWorkers=[];class JobWorker{constructor(a,b){this._port=a,this._number=b,this._isBusy=!1,this._port.onmessage=(a)=>this._OnMessage(a.data)}ImportScripts(a){this._port.postMessage({type:"_import_scripts",scripts:a})}SendBlob(a,b){this._port.postMessage({type:"_send_blob",blob:a,id:b})}SendJob(a){if(this._isBusy)throw new Error("already busy");this._isBusy=!0,this._port.postMessage(a,a.transferables)}IsBusy(){return this._isBusy}GetNumber(){return this._number}_OnMessage(a){const b=a.type;return"done"===b?void this._OnJobDone():void console.error("unknown message from worker '"+b+"'")}_OnJobDone(){this._isBusy=!1,this.MaybeStartNextJob()}MaybeStartNextJob(){if(!this._isBusy){const a=this._FindAvailableJob();if(-1!==a){const b=self.jobQueue[a],c=b.isBroadcast;c?(b.doneFlags[this._number]=!0,b.doneFlags.every((a)=>a)&&self.jobQueue.splice(a,1)):self.jobQueue.splice(a,1),this.SendJob(b)}}}_FindAvailableJob(){for(let a=0,b=self.jobQueue.length;a<b;++a){const b=self.jobQueue[a];if(!b.isBroadcast||!b.doneFlags[this._number])return a}return-1}}let number=0;function AddJobWorker(a){const b=new JobWorker(a,number++);self.jobWorkers.push(b),b.MaybeStartNextJob()}function CancelJob(a){for(let b=0,c=self.jobQueue.length;b<c;++b)if(self.jobQueue[b].jobId===a)return void self.jobQueue.splice(b,1)}self.addEventListener("message",(a)=>{const b=a.data,c=b.type;"_init"===c?(self.inputPort=b["in-port"],self.inputPort.onmessage=OnInputPortMessage):"_addJobWorker"===c&&AddJobWorker(b.port)});function OnInputPortMessage(a){const b=a.data,c=b.type;if("_cancel"===c)return void CancelJob(b.jobId);if("_import_scripts"===c){for(const a of self.jobWorkers)a.ImportScripts(b.scripts);return}if("_send_blob"===c){for(const a of self.jobWorkers)a.SendBlob(b.blob,b.id);return}self.jobQueue.push(b),b.isBroadcast&&(b.doneFlags=Array(self.jobWorkers.length).fill(!1),b.transferables=[]);for(const b of self.jobWorkers)b.MaybeStartNextJob()}